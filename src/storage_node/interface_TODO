// TODO: have all external interactions for add/remove/update go through here
// that way we can have configuration options to control whether we would do them
// or not. For example, we might want to have RO schema (as we are proxying some other
// database which is being directly accessed)
Node
    HandleQuery
    Meta MetaStorageInterface
    Store StorageInterface


// Handle all of the meta objects for schemaman which would be backed by some storageinterface 
// initialized with an internal-only metastorageinterface (one that doesn't allow changes, and only does GetMeta())
StorageMeta Interface
    Init()
    GetMeta()
    RefreshMeta()

	AddDatabase(db *metadata.Database) error
	RemoveDatabase(dbname string) error

	AddCollection(dbname string, collection *metadata.Collection) error
	UpdateCollection(dbname string, collection *metadata.Collection) error
	RemoveCollection(dbname string, collectionname string) error

	// TODO: move index and schema into a separate interface, since they are only
	// required for document stores (the rest are for all-- including k/v stores)
	AddIndex(dbname, collectionname string, index *metadata.CollectionIndex) error
	RemoveIndex(dbname, collectionname, indexname string) error

	// TODO: change this to a cache of the router schema?
	AddSchema(schema *metadata.Schema) error
	GetSchema(name string, version int64) *metadata.Schema
	ListSchemas() []*metadata.Schema
	RemoveSchema(name string, version int64) error


// TODO: RO version of this which has a "GetMeta()" for the datastore? (to use for import?) if not that can be a separate CLI (which might make more sense)
// The storage node defined for "storageinterface" might implement this one, if not then
// the node won't allow for any schema changes (since we can't do anything)
StorageSchemaInterface
	// Schema-Functions
	AddDatabase(db *metadata.Database) error
	RemoveDatabase(dbname string) error

	AddCollection(dbname string, collection *metadata.Collection) error
	UpdateCollection(dbname string, collection *metadata.Collection) error
	RemoveCollection(dbname string, collectionname string) error

	// TODO: move index and schema into a separate interface, since they are only
	// required for document stores (the rest are for all-- including k/v stores)
	AddIndex(dbname, collectionname string, index *metadata.CollectionIndex) error
	RemoveIndex(dbname, collectionname, indexname string) error

StorageInterface
	// Initialization, this is the "config_json" for the `storage_node`
	Init(metaInterface, map[string]interface{}) error

	// Data-Functions
	// TODO: split out the various functions into grouped interfaces that make sense
	// for now we'll just have one, but eventually we could support "TransactionalStorageNode" etc.
	// TODO: more specific types for each method
	Get(query.QueryArgs) *query.Result
	// TODO: pull up into the actual storage node itself, the implementation here
	// is simply switching between Update/Insert
	Set(query.QueryArgs) *query.Result
	Insert(query.QueryArgs) *query.Result
	Update(query.QueryArgs) *query.Result
	Delete(query.QueryArgs) *query.Result
	Filter(query.QueryArgs) *query.Result
